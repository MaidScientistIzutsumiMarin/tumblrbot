"""
This type stub file was generated by pyright.
"""

import argparse
import contextlib
import os
import requests
from argparse import ArgumentParser, Namespace
from collections import defaultdict
from collections.abc import Sequence
from dataclasses import dataclass
from types import ModuleType
from typing import Any, Callable, Iterator, TYPE_CHECKING, TextIO
from .util import LockedQueue, LogLevel
from .wget import WgetRetrieveWrapper
from typing_extensions import TypeAlias

if TYPE_CHECKING:
    ...
else:
    ...
JSONDict: TypeAlias = 'dict[str, Any]'
ytdl_module: ModuleType | None = ...
TAG_FMT = ...
TAGLINK_FMT = ...
EXIT_SUCCESS = ...
EXIT_FAILURE = ...
EXIT_INTERRUPT = ...
EXIT_ERRORS = ...
EXIT_NOPOSTS = ...
save_folder = ...
media_folder = ...
root_folder = ...
post_dir = ...
json_dir = ...
media_dir = ...
archive_dir = ...
theme_dir = ...
save_dir = ...
backup_css = ...
custom_css = ...
avatar_base = ...
dir_index = ...
tag_index_dir = ...
blog_name = ...
post_ext = ...
have_custom_css = ...
POST_TYPES = ...
TYPE_ANY = ...
TAG_ANY = ...
MAX_POSTS = ...
REM_POST_INC = ...
HTTP_RETRY = ...
FILE_ENCODING = ...
PREV_MUST_MATCH_OPTIONS = ...
MEDIA_PATH_OPTIONS = ...
MUST_MATCH_OPTIONS = ...
BACKUP_CHANGING_OPTIONS = ...
wget_retrieve: WgetRetrieveWrapper | None = ...
main_thread_lock = ...
multicond = ...
disable_note_scraper: set[str] = ...
disablens_lock = ...
downloading_media: set[str] = ...
downloading_media_cond = ...
def load_bs4(reason): # -> type[BeautifulSoup]:
    ...

class Logger:
    def __init__(self, quiet=..., file=...) -> None:
        ...
    
    def log(self, level: LogLevel, msg: str, account: bool = ...) -> None:
        ...
    
    def info(self, msg, account=...): # -> None:
        ...
    
    def warn(self, msg, account=...): # -> None:
        ...
    
    def error(self, msg, account=...): # -> None:
        ...
    
    def status(self, msg): # -> None:
        ...
    


logger = ...
def mkdir(dir_, recursive=...): # -> None:
    ...

def path_to(*parts): # -> str:
    ...

def open_file(open_fn, parts):
    ...

class open_outfile:
    def __init__(self, mode, *parts, **kwargs) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, exc_type, exc_value, tb): # -> None:
        ...
    


@contextlib.contextmanager
def open_text(*parts, mode=...) -> Iterator[TextIO]:
    ...

def strftime(fmt, t=...): # -> str:
    ...

def get_api_url(account: str, likes: bool) -> str:
    """construct the tumblr API URL"""
    ...

def parse_period_date(period): # -> list[int]:
    """Prepare the period start and end timestamps"""
    ...

def get_posts_key(likes: bool) -> str:
    ...

class ApiParser:
    TRY_LIMIT = ...
    session: requests.Session | None = ...
    api_key: str | None = ...
    def __init__(self, base: str, account: str, options: Namespace) -> None:
        ...
    
    @classmethod
    def setup(cls, api_key: str, no_ssl_verify: bool, user_agent: str, cookiefile: str | os.PathLike[str]) -> None:
        ...
    
    def read_archive(self, prev_archive): # -> bool:
        ...
    
    def get_initial(self) -> JSONDict | None:
        ...
    
    def apiparse(self, count, start=..., before=..., ident=...) -> JSONDict | None:
        ...
    


def add_exif(image_name: str, tags: set[str], exif: set[str]) -> None:
    ...

def save_style(): # -> None:
    ...

def find_files(path, match=...): # -> Generator[str, Any, None]:
    ...

def find_post_files(dirs: bool) -> Iterator[str]:
    ...

def match_avatar(name):
    ...

def get_avatar(prev_archive: str | os.PathLike[str], no_get: bool) -> None:
    ...

def get_style(prev_archive: str | os.PathLike[str], no_get: bool, use_dns_check: bool) -> None:
    """Get the blog's CSS by brute-forcing it from the home page.
    The v2 API has no method for getting the style directly.
    See https://groups.google.com/d/msg/tumblr-api/f-rRH6gOb6w/sAXZIeYx5AUJ"""
    ...

def maybe_copy_media(prev_archive, path_parts, pa_path_parts=...): # -> bool:
    ...

def check_optional_modules(options: Namespace) -> None:
    ...

def import_youtube_dl(): # -> ModuleType | Any:
    ...

class Index:
    index: defaultdict[int, defaultdict[int, list[LocalPost]]]
    def __init__(self, blog: TumblrBackup, posts_per_page: int, dirs: bool, reverse_month: bool, reverse_index: bool, tag_index: bool, body_class: str = ...) -> None:
        ...
    
    def add_post(self, post): # -> None:
        ...
    
    def save_index(self, index_dir=..., title=...): # -> None:
        ...
    
    def save_year(self, idx, archives, index_dir, year): # -> None:
        ...
    
    def save_month(self, archives, index_dir, year, month, tm): # -> str:
        ...
    


class TagIndex(Index):
    def __init__(self, name: str, blog: TumblrBackup, posts_per_page: int, dirs: bool, reverse_month: bool, reverse_index: bool, tag_index: bool) -> None:
        ...
    


class Indices:
    def __init__(self, blog: TumblrBackup, posts_per_page: int, dirs: bool, reverse_month: bool, reverse_index: bool, tag_index: bool) -> None:
        ...
    
    def build_index(self): # -> None:
        ...
    
    def save_index(self): # -> None:
        ...
    
    def save_tag_index(self): # -> None:
        ...
    


class TumblrBackup:
    def __init__(self, options: Namespace, orig_options: dict[str, Any], get_arg_default: Callable[[str], Any]) -> None:
        ...
    
    def exit_code(self): # -> Literal[4, 5, 0]:
        ...
    
    def header(self, title=..., body_class=..., subtitle=..., avatar=...): # -> str:
        ...
    
    @staticmethod
    def footer(base, previous_page, next_page): # -> str:
        ...
    
    @staticmethod
    def get_post_timestamp(post, bs4_class): # -> int:
        ...
    
    def process_existing_backup(self, account, prev_archive):
        @dataclass(frozen=True)
        class Options:
            ...
        
        
    
    def record_media(self, ident: int, urls: set[str]) -> None:
        ...
    
    def backup(self, account, prev_archive):
        """makes single files and an index for every post on a public Tumblr blog account"""
        ...
    


class TumblrPost:
    post_header = ...
    def __init__(self, post: JSONDict, options: Namespace, backup_account: str, prev_archive: str | None, pa_options: JSONDict | None, record_media: Callable[[int, set[str]], None]) -> None:
        ...
    
    def get_content(self): # -> LiteralString | str:
        """generates the content for this post"""
        ...
    
    def get_youtube_url(self, youtube_url): # -> str:
        ...
    
    def get_media_url(self, media_url, extension): # -> str:
        ...
    
    def get_image_url(self, image_url, offset): # -> str:
        """Saves an image if not saved yet. Returns the new URL or
        the original URL in case of download errors."""
        ...
    
    @staticmethod
    def maxsize_image_url(image_url): # -> str:
        ...
    
    def get_inline_image(self, match):
        """Saves an inline image if not saved yet. Returns the new <img> tag or
        the original one in case of download errors."""
        ...
    
    def get_inline_video_poster(self, match): # -> str:
        """Saves an inline video poster if not saved yet. Returns the new
        <video> tag or the original one in case of download errors."""
        ...
    
    def get_inline_video(self, match): # -> str:
        """Saves an inline video if not saved yet. Returns the new <video> tag
        or the original one in case of download errors."""
        ...
    
    def get_filename(self, parsed_url, image_names, offset=...): # -> str:
        """Determine the image file name depending on image_names"""
        ...
    
    def download_media(self, url, filename=..., offset=..., extension=...): # -> None:
        ...
    
    def get_post(self): # -> Any:
        """returns this post in HTML"""
        ...
    
    @staticmethod
    def tag_link(tag): # -> str:
        ...
    
    def get_path(self): # -> tuple[str, str, str] | tuple[str, str]:
        ...
    
    def save_post(self): # -> bool:
        """saves this post locally"""
        ...
    
    def get_json_content(self): # -> str:
        ...
    


class BlosxomPost(TumblrPost):
    def get_image_url(self, image_url, offset):
        ...
    
    def get_post(self): # -> Any:
        """returns this post as a Blosxom post"""
        ...
    


class LocalPost:
    def __init__(self, post_file: str, tag_index: bool) -> None:
        ...
    
    def get_post(self, in_tag_index): # -> str:
        ...
    


class ThreadPool:
    queue: LockedQueue[Callable[[], None]]
    def __init__(self, threads: int, max_queue: int = ...) -> None:
        ...
    
    def add_work(self, *args, **kwargs): # -> None:
        ...
    
    def wait(self): # -> None:
        ...
    
    def cancel(self): # -> None:
        ...
    
    def handler(self): # -> None:
        ...
    


class CSVCallback(argparse.Action):
    def __call__(self, parser: ArgumentParser, namespace: Namespace, values: str | Sequence[Any] | None, option_string: str | None = ...) -> None:
        ...
    


class RequestCallback(argparse.Action):
    def __call__(self, parser: ArgumentParser, namespace: Namespace, values: str | Sequence[Any] | None, option_string: str | None = ...) -> None:
        ...
    


class TagsCallback(RequestCallback):
    def __call__(self, parser: ArgumentParser, namespace: Namespace, values: str | Sequence[Any] | None, option_string: str | None = ...): # -> None:
        ...
    


class PeriodCallback(argparse.Action):
    def __call__(self, parser: ArgumentParser, namespace: Namespace, values: str | Sequence[Any] | None, option_string: str | None = ...) -> None:
        ...
    


class IdFileCallback(argparse.Action):
    def __call__(self, parser: ArgumentParser, namespace: Namespace, values: str | Sequence[Any] | None, option_string: str | None = ...) -> None:
        ...
    


def main(): # -> Literal[1, 0, 3, 4, 5]:
    ...

